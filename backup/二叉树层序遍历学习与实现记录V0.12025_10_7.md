  这是我的第一篇日志，由此记录我的数据结构学习过程，希望借此回顾并巩固新知识点，同时锻炼我的观点输出能力。或许有一天我会把日志公开，不过可能得2，3年之后了，期间打磨我会不断打磨自己的能力。
 
     今天，我准备再次回顾二叉树中的层序遍历。首先，回顾主要知识点。
      1.树的结点  树的结点由数据域和指针域构成  ，其中数据域存放相关信息，而指针域存放该父节点指向的左孩子与右孩子
如下图

<img width="267" height="151" alt="Image" src="https://github.com/user-attachments/assets/dc3d96de-ed7f-40f4-bfc6-0883c937500a" />

2.队列 与栈先进后出不同，队列的原则为先进先出，这为我们下文层序遍历提供了条件这里，先按下不表
       队列的代码组成为数据域与指针域，在此我将采用循环队列的方式完成，首先定义结构体queue

图片

        其中的data即为数据域，用来存放树的结点，而通过指针front与rear的移动，达到删除和增添结点的效果
介绍完这些，接下来进入具体的操作过程
        首先要遍历二叉树就要先创建二叉树，我们想到创建一个函数void creat_tree(tree_node**p,int x)
图片
      其中p表示指向指向tree_node元素的指针的指针，x表示要传入的数据，可能这里会有点疑问：为什么不直接传入指向tree_node元素的指针呢，当时我也咋想咋想不通，与各个ai问了半天，最后我的理解为：因为我们操作的指针变了。如果在此传入一级指针，因为C语言函数为值传递，说以传入仅仅是一个副本，相当于仅仅在另一个时空改变了你想改变的指针，但函数执行完毕后对你原来想改变的东西没有丝毫影响，这样我们的疑问就可以解决。回到函数creat_tree我们要先为传入的指针分配空间，如果没有这一步那你就相当于立了块牌子，说这是我家准备施工，但后面根本没有空间可以施工。
接着，我们将要传入的数据传入该数节点的data中，再将（*node)->left,与（node*）->right设为空指针，等待下一步的赋值。
到此我们完成了creat-tree函数的构建，接下来便是传入数据，如下图
图片
图片
今天先写到这里，之后有空我将继续完成剩余的队列遍历部分。













