这是我的第一篇日志，
用来记录我的数据结构学习过程，
希望借此回顾并巩固新知识点，
同时锻炼我的观点输出能力。
或许有一天我会把日志公开，
不过可能得 2、3 年之后了，
期间我会不断打磨自己的能力。

---

今天，我准备再次回顾二叉树中的层序遍历。
首先，回顾主要知识点。

1. 树的结点  
树的结点由数据域和指针域构成，
其中数据域存放相关信息，
而指针域存放该父节点指向的左孩子与右孩子。
如下图所示：

<img width="267" height="151" alt="Image" src="https://github.com/user-attachments/assets/9c2c0dfc-0b68-4a6a-8e51-246bc6dcbb94" />

2. 队列  
与栈先进后出不同，
队列的原则为先进先出，
这为我们下文层序遍历提供了条件，
这里先按下不表。
队列的代码组成为数据域与指针域，
在此我将采用循环队列的方式完成，
首先定义结构体 queue：

<img width="273" height="176" alt="Image" src="https://github.com/user-attachments/assets/e7d9f194-161a-4220-9bc1-4080832c20b9" />

其中的 data 即为数据域，
用来存放树的结点，
而通过指针 front 与 rear 的移动，
达到删除和增添结点的效果。

介绍完这些，接下来进入具体的操作过程。

首先要遍历二叉树就要先创建二叉树，
我们想到创建一个函数
void creat_tree(tree_node **p, int x)
如下图所示：

<img width="519" height="174" alt="Image" src="https://github.com/user-attachments/assets/8fa14f9e-94c6-46ad-af69-25389872e415" />

其中 p 表示指向 tree_node 元素指针的指针，
x 表示要传入的数据。

可能这里会有点疑问：
为什么不直接传入指向 tree_node 元素的指针呢？
当时我也咋想咋想不通，
与各个 AI 问了半天，
最后我的理解为：
因为我们操作的指针变了。
如果传入一级指针，
由于 C 语言函数是值传递，
传入的仅仅是一个副本，
相当于在另一个时空改变了你想改变的指针，
但函数执行完毕后，
对原来想改变的东西没有丝毫影响，
这样疑问就可以解决。

回到函数 creat_tree，
我们要先为传入的指针分配空间，
如果没有这一步，
那你就相当于立了块牌子，
说这是我家准备施工，
但后面根本没有空间可以施工。

接着，我们将要传入的数据
传入该树节点的 data 中，
再将 (*node)->left 与 (*node)->right
设为空指针，
等待下一步的赋值。

到此我们完成了 creat-tree 函数的构建，
接下来便是传入数据，
如下图所示：

<img width="406" height="228" alt="Image" src="https://github.com/user-attachments/assets/6ffa7cd2-bbce-4fa1-b7e1-7629acc80344" />

![Image](https://github.com/user-attachments/assets/cffbfeba-400a-45eb-887f-07d007f13a47)

今天先写到这里，
之后有空我将继续完成剩余的队列遍历部分。